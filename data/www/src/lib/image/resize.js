import { clampRect } from './util.js';
// nearest neighbor scaling
export const pointResize = (src, dest, srcRect = [0, 0, src.width, src.height], destRect = [0, 0, dest.width, dest.height]) => {
    const [sx, sy, sw, sh] = clampRect(src.width, src.height, srcRect);
    const [dx, dy, dw, dh] = clampRect(dest.width, dest.height, destRect);
    const scaleW = sw / dw;
    const scaleH = sh / dh;
    const srcData = new Uint32Array(src.data.buffer);
    const destData = new Uint32Array(dest.data.buffer);
    for (let y = 0; y < dh; y++) {
        const srcY = Math.floor(y * scaleH) + sy;
        for (let x = 0; x < dw; x++) {
            const srcX = Math.floor(x * scaleW) + sx;
            const srcIndex = srcY * src.width + srcX;
            const destIndex = (y + dy) * dest.width + (x + dx);
            destData[destIndex] = srcData[srcIndex];
        }
    }
    return dest;
};
export const bilinearResize = (src, dest, srcRect = [0, 0, src.width, src.height], destRect = [0, 0, dest.width, dest.height]) => {
    const [sx, sy, sw, sh] = clampRect(src.width, src.height, srcRect);
    const [dx, dy, dw, dh] = clampRect(dest.width, dest.height, destRect);
    const srcData = new Uint32Array(src.data.buffer);
    const destData = new Uint32Array(dest.data.buffer);
    // These are the scale factors from dest -> src dimensions
    const scaleW = sw / dw;
    const scaleH = sh / dh;
    // Helper to safely fetch a pixel (as 32-bit) at (x, y) from srcData
    function getPixel(x, y) {
        // Clamp to edges to avoid sampling out of range
        x = Math.max(0, Math.min(src.width - 1, x));
        y = Math.max(0, Math.min(src.height - 1, y));
        return srcData[y * src.width + x];
    }
    for (let y = 0; y < dh; y++) {
        // Floating-point Y position in source
        const srcY = (y + 0.5) * scaleH - 0.5 + sy;
        // Integer Y positions and fractional part
        const y0 = Math.floor(srcY);
        const yFrac = srcY - y0;
        const y1 = y0 + 1;
        for (let x = 0; x < dw; x++) {
            // Floating-point X position in source
            const srcX = (x + 0.5) * scaleW - 0.5 + sx;
            // Integer X positions and fractional part
            const x0 = Math.floor(srcX);
            const xFrac = srcX - x0;
            const x1 = x0 + 1;
            // Fetch the four nearest pixels in the source
            // c00 = top-left, c10 = top-right, c01 = bottom-left, c11 = bottom-right
            const c00 = getPixel(x0, y0);
            const c10 = getPixel(x1, y0);
            const c01 = getPixel(x0, y1);
            const c11 = getPixel(x1, y1);
            // Extract RGBA components from each 32-bit pixel
            const r00 = c00 & 0xFF;
            const g00 = (c00 >> 8) & 0xFF;
            const b00 = (c00 >> 16) & 0xFF;
            const a00 = (c00 >> 24) & 0xFF;
            const r10 = c10 & 0xFF;
            const g10 = (c10 >> 8) & 0xFF;
            const b10 = (c10 >> 16) & 0xFF;
            const a10 = (c10 >> 24) & 0xFF;
            const r01 = c01 & 0xFF;
            const g01 = (c01 >> 8) & 0xFF;
            const b01 = (c01 >> 16) & 0xFF;
            const a01 = (c01 >> 24) & 0xFF;
            const r11 = c11 & 0xFF;
            const g11 = (c11 >> 8) & 0xFF;
            const b11 = (c11 >> 16) & 0xFF;
            const a11 = (c11 >> 24) & 0xFF;
            // Bilinear interpolation in X, then in Y:
            //   out = c00*(1-xFrac)*(1-yFrac) + c10*xFrac*(1-yFrac) +
            //         c01*(1-xFrac)*yFrac     + c11*xFrac*yFrac
            const r = Math.round(r00 * (1 - xFrac) * (1 - yFrac) +
                r10 * (xFrac) * (1 - yFrac) +
                r01 * (1 - xFrac) * (yFrac) +
                r11 * (xFrac) * (yFrac));
            const g = Math.round(g00 * (1 - xFrac) * (1 - yFrac) +
                g10 * (xFrac) * (1 - yFrac) +
                g01 * (1 - xFrac) * (yFrac) +
                g11 * (xFrac) * (yFrac));
            const b = Math.round(b00 * (1 - xFrac) * (1 - yFrac) +
                b10 * (xFrac) * (1 - yFrac) +
                b01 * (1 - xFrac) * (yFrac) +
                b11 * (xFrac) * (yFrac));
            const a = Math.round(a00 * (1 - xFrac) * (1 - yFrac) +
                a10 * (xFrac) * (1 - yFrac) +
                a01 * (1 - xFrac) * (yFrac) +
                a11 * (xFrac) * (yFrac));
            // Pack RGBA back into a 32-bit integer (assuming little-endian RGBA layout).
            // If your environment uses BGRA or ABGR, reorder accordingly.
            const rgba = (a << 24) |
                (b << 16) |
                (g << 8) |
                (r);
            const destIndex = (y + dy) * dest.width + (x + dx);
            destData[destIndex] = rgba;
        }
    }
    return dest;
};
/*
// compute vector index from matrix one
    function ivect(ix, iy, w) {
        // byte array, r,g,b,a
        return((ix + w * iy) * 4);
    }

    function bilinear(srcImg, destImg, scale) {
        // c.f.: wikipedia english article on bilinear interpolation
        // taking the unit square, the inner loop looks like this
        // note: there's a function call inside the double loop to this one
        // maybe a performance killer, optimize this whole code as you need
        function inner(f00, f10, f01, f11, x, y) {
            var un_x = 1.0 - x; var un_y = 1.0 - y;
            return (f00 * un_x * un_y + f10 * x * un_y + f01 * un_x * y + f11 * x * y);
        }
        var i, j;
        var iyv, iy0, iy1, ixv, ix0, ix1;
        var idxD, idxS00, idxS10, idxS01, idxS11;
        var dx, dy;
        var r, g, b, a;
        for (i = 0; i < destImg.height; ++i) {
            iyv = i / scale;
            iy0 = Math.floor(iyv);
            // Math.ceil can go over bounds
            iy1 = ( Math.ceil(iyv) > (srcImg.height-1) ? (srcImg.height-1) : Math.ceil(iyv) );
            for (j = 0; j < destImg.width; ++j) {
                ixv = j / scale;
                ix0 = Math.floor(ixv);
                // Math.ceil can go over bounds
                ix1 = ( Math.ceil(ixv) > (srcImg.width-1) ? (srcImg.width-1) : Math.ceil(ixv) );
                idxD = ivect(j, i, destImg.width);
                // matrix to vector indices
                idxS00 = ivect(ix0, iy0, srcImg.width);
                idxS10 = ivect(ix1, iy0, srcImg.width);
                idxS01 = ivect(ix0, iy1, srcImg.width);
                idxS11 = ivect(ix1, iy1, srcImg.width);
                // overall coordinates to unit square
                dx = ixv - ix0; dy = iyv - iy0;
                // I let the r, g, b, a on purpose for debugging
                r = inner(srcImg.data[idxS00], srcImg.data[idxS10],
                    srcImg.data[idxS01], srcImg.data[idxS11], dx, dy);
                destImg.data[idxD] = r;

                g = inner(srcImg.data[idxS00+1], srcImg.data[idxS10+1],
                    srcImg.data[idxS01+1], srcImg.data[idxS11+1], dx, dy);
                destImg.data[idxD+1] = g;

                b = inner(srcImg.data[idxS00+2], srcImg.data[idxS10+2],
                    srcImg.data[idxS01+2], srcImg.data[idxS11+2], dx, dy);
                destImg.data[idxD+2] = b;

                a = inner(srcImg.data[idxS00+3], srcImg.data[idxS10+3],
                    srcImg.data[idxS01+3], srcImg.data[idxS11+3], dx, dy);
                destImg.data[idxD+3] = a;
            }
        }
    }
*/
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzaXplLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9pbWFnZS9yZXNpemUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLFdBQVcsQ0FBQTtBQUVyQywyQkFBMkI7QUFDM0IsTUFBTSxDQUFDLE1BQU0sV0FBVyxHQUFHLENBQ3pCLEdBQWMsRUFBRSxJQUFlLEVBQy9CLFVBQWMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUMzQyxXQUFlLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsRUFDOUMsRUFBRTtJQUNGLE1BQU0sQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFBO0lBQ2xFLE1BQU0sQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFBO0lBRXJFLE1BQU0sTUFBTSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUE7SUFDdEIsTUFBTSxNQUFNLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQTtJQUV0QixNQUFNLE9BQU8sR0FBRyxJQUFJLFdBQVcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO0lBQ2hELE1BQU0sUUFBUSxHQUFHLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUE7SUFFbEQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVB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RyxHQUFHLENBQUMsR0FBRyxJQUFJLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztZQUUvQixNQUFNLEdBQUcsR0FBSSxHQUFHLEdBQVUsSUFBSSxDQUFDO1lBQy9CLE1BQU0sR0FBRyxHQUFHLENBQUMsR0FBRyxJQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztZQUMvQixNQUFNLEdBQUcsR0FBRyxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUM7WUFDL0IsTUFBTSxHQUFHLEdBQUcsQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDO1lBRS9CLE1BQU0sR0FBRyxHQUFJLEdBQUcsR0FBVSxJQUFJLENBQUM7WUFDL0IsTUFBTSxHQUFHLEdBQUcsQ0FBQyxHQUFHLElBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO1lBQy9CLE1BQU0sR0FBRyxHQUFHLENBQUMsR0FBRyxJQUFJLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztZQUMvQixNQUFNLEdBQUcsR0FBRyxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUM7WUFFL0IsTUFBTSxHQUFHLEdBQUksR0FBRyxHQUFVLElBQUksQ0FBQztZQUMvQixNQUFNLEdBQUcsR0FBRyxDQUFDLEdBQUcsSUFBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7WUFDL0IsTUFBTSxHQUFHLEdBQUcsQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDO1lBQy9CLE1BQU0sR0FBRyxHQUFHLENBQUMsR0FBRyxJQUFJLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztZQUUvQiwwQ0FBMEM7WUFDMUMsMERBQTBEO1lBQzFELG9EQUFvRDtZQUNwRCxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUNsQixHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO2dCQUMvQixHQUFHLEdBQUcsQ0FBTSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7Z0JBQ2hDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFNLEtBQUssQ0FBQztnQkFDaEMsR0FBRyxHQUFHLENBQU0sS0FBSyxDQUFDLEdBQUcsQ0FBTSxLQUFLLENBQUMsQ0FDbEMsQ0FBQztZQUNGLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQ2xCLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7Z0JBQy9CLEdBQUcsR0FBRyxDQUFNLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztnQkFDaEMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQU0sS0FBSyxDQUFDO2dCQUNoQyxHQUFHLEdBQUcsQ0FBTSxLQUFLLENBQUMsR0FBRyxDQUFNLEtBQUssQ0FBQyxDQUNsQyxDQUFDO1lBQ0YsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FDbEIsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztnQkFDL0IsR0FBRyxHQUFHLENBQU0sS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO2dCQUNoQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBTSxLQUFLLENBQUM7Z0JBQ2hDLEdBQUcsR0FBRyxDQUFNLEtBQUssQ0FBQyxHQUFHLENBQU0sS0FBSyxDQUFDLENBQ2xDLENBQUM7WUFDRixNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUNsQixHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO2dCQUMvQixHQUFHLEdBQUcsQ0FBTSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7Z0JBQ2hDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFNLEtBQUssQ0FBQztnQkFDaEMsR0FBRyxHQUFHLENBQU0sS0FBSyxDQUFDLEdBQUcsQ0FBTSxLQUFLLENBQUMsQ0FDbEMsQ0FBQztZQUVGLDZFQUE2RTtZQUM3RSw4REFBOEQ7WUFDOUQsTUFBTSxJQUFJLEdBQ1IsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUNULENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFDVCxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ1IsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUVOLE1BQU0sU0FBUyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7WUFDbkQsUUFBUSxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUM3QixDQUFDO0lBQ0gsQ0FBQztJQUVELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQyxDQUFDO0FBR0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUEwREUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUNCB9IGZyb20gJy4uL3R5cGVzLmpzJ1xyXG5pbXBvcnQgeyBjbGFtcFJlY3QgfSBmcm9tICcuL3V0aWwuanMnXHJcblxyXG4vLyBuZWFyZXN0IG5laWdoYm9yIHNjYWxpbmdcclxuZXhwb3J0IGNvbnN0IHBvaW50UmVzaXplID0gKFxyXG4gIHNyYzogSW1hZ2VEYXRhLCBkZXN0OiBJbWFnZURhdGEsXHJcbiAgc3JjUmVjdDogVDQgPSBbMCwgMCwgc3JjLndpZHRoLCBzcmMuaGVpZ2h0XSxcclxuICBkZXN0UmVjdDogVDQgPSBbMCwgMCwgZGVzdC53aWR0aCwgZGVzdC5oZWlnaHRdXHJcbikgPT4ge1xyXG4gIGNvbnN0IFtzeCwgc3ksIHN3LCBzaF0gPSBjbGFtcFJlY3Qoc3JjLndpZHRoLCBzcmMuaGVpZ2h0LCBzcmNSZWN0KVxyXG4gIGNvbnN0IFtkeCwgZHksIGR3LCBkaF0gPSBjbGFtcFJlY3QoZGVzdC53aWR0aCwgZGVzdC5oZWlnaHQsIGRlc3RSZWN0KVxyXG5cclxuICBjb25zdCBzY2FsZVcgPSBzdyAvIGR3XHJcbiAgY29uc3Qgc2NhbGVIID0gc2ggLyBkaFxyXG5cclxuICBjb25zdCBzcmNEYXRhID0gbmV3IFVpbnQzMkFycmF5KHNyYy5kYXRhLmJ1ZmZlcilcclxuICBjb25zdCBkZXN0RGF0YSA9IG5ldyBVaW50MzJBcnJheShkZXN0LmRhdGEuYnVmZmVyKVxyXG5cclxuICBmb3IgKGxldCB5ID0gMDsgeSA8IGRoOyB5KyspIHtcclxuICAgIGNvbnN0IHNyY1kgPSBNYXRoLmZsb29yKHkgKiBzY2FsZUgpICsgc3lcclxuXHJcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGR3OyB4KyspIHtcclxuICAgICAgY29uc3Qgc3JjWCA9IE1hdGguZmxvb3IoeCAqIHNjYWxlVykgKyBzeFxyXG5cclxuICAgICAgY29uc3Qgc3JjSW5kZXggPSBzcmNZICogc3JjLndpZHRoICsgc3JjWFxyXG4gICAgICBjb25zdCBkZXN0SW5kZXggPSAoeSArIGR5KSAqIGRlc3Qud2lkdGggKyAoeCArIGR4KVxyXG5cclxuICAgICAgZGVzdERhdGFbZGVzdEluZGV4XSA9IHNyY0RhdGFbc3JjSW5kZXhdXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZGVzdFxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgYmlsaW5lYXJSZXNpemUgPSAoXHJcbiAgc3JjOiBJbWFnZURhdGEsXHJcbiAgZGVzdDogSW1hZ2VEYXRhLFxyXG4gIHNyY1JlY3Q6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzAsIDAsIHNyYy53aWR0aCwgc3JjLmhlaWdodF0sXHJcbiAgZGVzdFJlY3Q6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzAsIDAsIGRlc3Qud2lkdGgsIGRlc3QuaGVpZ2h0XVxyXG4pID0+IHtcclxuICBjb25zdCBbc3gsIHN5LCBzdywgc2hdID0gY2xhbXBSZWN0KHNyYy53aWR0aCwgc3JjLmhlaWdodCwgc3JjUmVjdCk7XHJcbiAgY29uc3QgW2R4LCBkeSwgZHcsIGRoXSA9IGNsYW1wUmVjdChkZXN0LndpZHRoLCBkZXN0LmhlaWdodCwgZGVzdFJlY3QpO1xyXG5cclxuICBjb25zdCBzcmNEYXRhID0gbmV3IFVpbnQzMkFycmF5KHNyYy5kYXRhLmJ1ZmZlcik7XHJcbiAgY29uc3QgZGVzdERhdGEgPSBuZXcgVWludDMyQXJyYXkoZGVzdC5kYXRhLmJ1ZmZlcik7XHJcblxyXG4gIC8vIFRoZXNlIGFyZSB0aGUgc2NhbGUgZmFjdG9ycyBmcm9tIGRlc3QgLT4gc3JjIGRpbWVuc2lvbnNcclxuICBjb25zdCBzY2FsZVcgPSBzdyAvIGR3O1xyXG4gIGNvbnN0IHNjYWxlSCA9IHNoIC8gZGg7XHJcblxyXG4gIC8vIEhlbHBlciB0byBzYWZlbHkgZmV0Y2ggYSBwaXhlbCAoYXMgMzItYml0KSBhdCAoeCwgeSkgZnJvbSBzcmNEYXRhXHJcbiAgZnVuY3Rpb24gZ2V0UGl4ZWwoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgLy8gQ2xhbXAgdG8gZWRnZXMgdG8gYXZvaWQgc2FtcGxpbmcgb3V0IG9mIHJhbmdlXHJcbiAgICB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc3JjLndpZHRoIC0gMSwgeCkpO1xyXG4gICAgeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHNyYy5oZWlnaHQgLSAxLCB5KSk7XHJcbiAgICByZXR1cm4gc3JjRGF0YVt5ICogc3JjLndpZHRoICsgeF07XHJcbiAgfVxyXG5cclxuICBmb3IgKGxldCB5ID0gMDsgeSA8IGRoOyB5KyspIHtcclxuICAgIC8vIEZsb2F0aW5nLXBvaW50IFkgcG9zaXRpb24gaW4gc291cmNlXHJcbiAgICBjb25zdCBzcmNZID0gKHkgKyAwLjUpICogc2NhbGVIIC0gMC41ICsgc3k7XHJcbiAgICAvLyBJbnRlZ2VyIFkgcG9zaXRpb25zIGFuZCBmcmFjdGlvbmFsIHBhcnRcclxuICAgIGNvbnN0IHkwID0gTWF0aC5mbG9vcihzcmNZKTtcclxuICAgIGNvbnN0IHlGcmFjID0gc3JjWSAtIHkwO1xyXG4gICAgY29uc3QgeTEgPSB5MCArIDE7XHJcblxyXG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCBkdzsgeCsrKSB7XHJcbiAgICAgIC8vIEZsb2F0aW5nLXBvaW50IFggcG9zaXRpb24gaW4gc291cmNlXHJcbiAgICAgIGNvbnN0IHNyY1ggPSAoeCArIDAuNSkgKiBzY2FsZVcgLSAwLjUgKyBzeDtcclxuICAgICAgLy8gSW50ZWdlciBYIHBvc2l0aW9ucyBhbmQgZnJhY3Rpb25hbCBwYXJ0XHJcbiAgICAgIGNvbnN0IHgwID0gTWF0aC5mbG9vcihzcmNYKTtcclxuICAgICAgY29uc3QgeEZyYWMgPSBzcmNYIC0geDA7XHJcbiAgICAgIGNvbnN0IHgxID0geDAgKyAxO1xyXG5cclxuICAgICAgLy8gRmV0Y2ggdGhlIGZvdXIgbmVhcmVzdCBwaXhlbHMgaW4gdGhlIHNvdXJjZVxyXG4gICAgICAvLyBjMDAgPSB0b3AtbGVmdCwgYzEwID0gdG9wLXJpZ2h0LCBjMDEgPSBib3R0b20tbGVmdCwgYzExID0gYm90dG9tLXJpZ2h0XHJcbiAgICAgIGNvbnN0IGMwMCA9IGdldFBpeGVsKHgwLCB5MCk7XHJcbiAgICAgIGNvbnN0IGMxMCA9IGdldFBpeGVsKHgxLCB5MCk7XHJcbiAgICAgIGNvbnN0IGMwMSA9IGdldFBpeGVsKHgwLCB5MSk7XHJcbiAgICAgIGNvbnN0IGMxMSA9IGdldFBpeGVsKHgxLCB5MSk7XHJcblxyXG4gICAgICAvLyBFeHRyYWN0IFJHQkEgY29tcG9uZW50cyBmcm9tIGVhY2ggMzItYml0IHBpeGVsXHJcbiAgICAgIGNvbnN0IHIwMCA9ICBjMDAgICAgICAgICYgMHhGRjtcclxuICAgICAgY29uc3QgZzAwID0gKGMwMCA+PiAgOCkgJiAweEZGO1xyXG4gICAgICBjb25zdCBiMDAgPSAoYzAwID4+IDE2KSAmIDB4RkY7XHJcbiAgICAgIGNvbnN0IGEwMCA9IChjMDAgPj4gMjQpICYgMHhGRjtcclxuXHJcbiAgICAgIGNvbnN0IHIxMCA9ICBjMTAgICAgICAgICYgMHhGRjtcclxuICAgICAgY29uc3QgZzEwID0gKGMxMCA+PiAgOCkgJiAweEZGO1xyXG4gICAgICBjb25zdCBiMTAgPSAoYzEwID4+IDE2KSAmIDB4RkY7XHJcbiAgICAgIGNvbnN0IGExMCA9IChjMTAgPj4gMjQpICYgMHhGRjtcclxuXHJcbiAgICAgIGNvbnN0IHIwMSA9ICBjMDEgICAgICAgICYgMHhGRjtcclxuICAgICAgY29uc3QgZzAxID0gKGMwMSA+PiAgOCkgJiAweEZGO1xyXG4gICAgICBjb25zdCBiMDEgPSAoYzAxID4+IDE2KSAmIDB4RkY7XHJcbiAgICAgIGNvbnN0IGEwMSA9IChjMDEgPj4gMjQpICYgMHhGRjtcclxuXHJcbiAgICAgIGNvbnN0IHIxMSA9ICBjMTEgICAgICAgICYgMHhGRjtcclxuICAgICAgY29uc3QgZzExID0gKGMxMSA+PiAgOCkgJiAweEZGO1xyXG4gICAgICBjb25zdCBiMTEgPSAoYzExID4+IDE2KSAmIDB4RkY7XHJcbiAgICAgIGNvbnN0IGExMSA9IChjMTEgPj4gMjQpICYgMHhGRjtcclxuXHJcbiAgICAgIC8vIEJpbGluZWFyIGludGVycG9sYXRpb24gaW4gWCwgdGhlbiBpbiBZOlxyXG4gICAgICAvLyAgIG91dCA9IGMwMCooMS14RnJhYykqKDEteUZyYWMpICsgYzEwKnhGcmFjKigxLXlGcmFjKSArXHJcbiAgICAgIC8vICAgICAgICAgYzAxKigxLXhGcmFjKSp5RnJhYyAgICAgKyBjMTEqeEZyYWMqeUZyYWNcclxuICAgICAgY29uc3QgciA9IE1hdGgucm91bmQoXHJcbiAgICAgICAgcjAwICogKDEgLSB4RnJhYykgKiAoMSAtIHlGcmFjKSArXHJcbiAgICAgICAgcjEwICogKCAgICAgeEZyYWMpICogKDEgLSB5RnJhYykgK1xyXG4gICAgICAgIHIwMSAqICgxIC0geEZyYWMpICogKCAgICAgeUZyYWMpICtcclxuICAgICAgICByMTEgKiAoICAgICB4RnJhYykgKiAoICAgICB5RnJhYylcclxuICAgICAgKTtcclxuICAgICAgY29uc3QgZyA9IE1hdGgucm91bmQoXHJcbiAgICAgICAgZzAwICogKDEgLSB4RnJhYykgKiAoMSAtIHlGcmFjKSArXHJcbiAgICAgICAgZzEwICogKCAgICAgeEZyYWMpICogKDEgLSB5RnJhYykgK1xyXG4gICAgICAgIGcwMSAqICgxIC0geEZyYWMpICogKCAgICAgeUZyYWMpICtcclxuICAgICAgICBnMTEgKiAoICAgICB4RnJhYykgKiAoICAgICB5RnJhYylcclxuICAgICAgKTtcclxuICAgICAgY29uc3QgYiA9IE1hdGgucm91bmQoXHJcbiAgICAgICAgYjAwICogKDEgLSB4RnJhYykgKiAoMSAtIHlGcmFjKSArXHJcbiAgICAgICAgYjEwICogKCAgICAgeEZyYWMpICogKDEgLSB5RnJhYykgK1xyXG4gICAgICAgIGIwMSAqICgxIC0geEZyYWMpICogKCAgICAgeUZyYWMpICtcclxuICAgICAgICBiMTEgKiAoICAgICB4RnJhYykgKiAoICAgICB5RnJhYylcclxuICAgICAgKTtcclxuICAgICAgY29uc3QgYSA9IE1hdGgucm91bmQoXHJcbiAgICAgICAgYTAwICogKDEgLSB4RnJhYykgKiAoMSAtIHlGcmFjKSArXHJcbiAgICAgICAgYTEwICogKCAgICAgeEZyYWMpICogKDEgLSB5RnJhYykgK1xyXG4gICAgICAgIGEwMSAqICgxIC0geEZyYWMpICogKCAgICAgeUZyYWMpICtcclxuICAgICAgICBhMTEgKiAoICAgICB4RnJhYykgKiAoICAgICB5RnJhYylcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIFBhY2sgUkdCQSBiYWNrIGludG8gYSAzMi1iaXQgaW50ZWdlciAoYXNzdW1pbmcgbGl0dGxlLWVuZGlhbiBSR0JBIGxheW91dCkuXHJcbiAgICAgIC8vIElmIHlvdXIgZW52aXJvbm1lbnQgdXNlcyBCR1JBIG9yIEFCR1IsIHJlb3JkZXIgYWNjb3JkaW5nbHkuXHJcbiAgICAgIGNvbnN0IHJnYmEgPVxyXG4gICAgICAgIChhIDw8IDI0KSB8XHJcbiAgICAgICAgKGIgPDwgMTYpIHxcclxuICAgICAgICAoZyA8PCA4KSB8XHJcbiAgICAgICAgKHIpO1xyXG5cclxuICAgICAgY29uc3QgZGVzdEluZGV4ID0gKHkgKyBkeSkgKiBkZXN0LndpZHRoICsgKHggKyBkeCk7XHJcbiAgICAgIGRlc3REYXRhW2Rlc3RJbmRleF0gPSByZ2JhO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGRlc3Q7XHJcbn07XHJcblxyXG5cclxuLypcclxuLy8gY29tcHV0ZSB2ZWN0b3IgaW5kZXggZnJvbSBtYXRyaXggb25lXHJcbiAgICBmdW5jdGlvbiBpdmVjdChpeCwgaXksIHcpIHtcclxuICAgICAgICAvLyBieXRlIGFycmF5LCByLGcsYixhXHJcbiAgICAgICAgcmV0dXJuKChpeCArIHcgKiBpeSkgKiA0KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBiaWxpbmVhcihzcmNJbWcsIGRlc3RJbWcsIHNjYWxlKSB7XHJcbiAgICAgICAgLy8gYy5mLjogd2lraXBlZGlhIGVuZ2xpc2ggYXJ0aWNsZSBvbiBiaWxpbmVhciBpbnRlcnBvbGF0aW9uXHJcbiAgICAgICAgLy8gdGFraW5nIHRoZSB1bml0IHNxdWFyZSwgdGhlIGlubmVyIGxvb3AgbG9va3MgbGlrZSB0aGlzXHJcbiAgICAgICAgLy8gbm90ZTogdGhlcmUncyBhIGZ1bmN0aW9uIGNhbGwgaW5zaWRlIHRoZSBkb3VibGUgbG9vcCB0byB0aGlzIG9uZVxyXG4gICAgICAgIC8vIG1heWJlIGEgcGVyZm9ybWFuY2Uga2lsbGVyLCBvcHRpbWl6ZSB0aGlzIHdob2xlIGNvZGUgYXMgeW91IG5lZWRcclxuICAgICAgICBmdW5jdGlvbiBpbm5lcihmMDAsIGYxMCwgZjAxLCBmMTEsIHgsIHkpIHtcclxuICAgICAgICAgICAgdmFyIHVuX3ggPSAxLjAgLSB4OyB2YXIgdW5feSA9IDEuMCAtIHk7XHJcbiAgICAgICAgICAgIHJldHVybiAoZjAwICogdW5feCAqIHVuX3kgKyBmMTAgKiB4ICogdW5feSArIGYwMSAqIHVuX3ggKiB5ICsgZjExICogeCAqIHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaSwgajtcclxuICAgICAgICB2YXIgaXl2LCBpeTAsIGl5MSwgaXh2LCBpeDAsIGl4MTtcclxuICAgICAgICB2YXIgaWR4RCwgaWR4UzAwLCBpZHhTMTAsIGlkeFMwMSwgaWR4UzExO1xyXG4gICAgICAgIHZhciBkeCwgZHk7XHJcbiAgICAgICAgdmFyIHIsIGcsIGIsIGE7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlc3RJbWcuaGVpZ2h0OyArK2kpIHtcclxuICAgICAgICAgICAgaXl2ID0gaSAvIHNjYWxlO1xyXG4gICAgICAgICAgICBpeTAgPSBNYXRoLmZsb29yKGl5dik7XHJcbiAgICAgICAgICAgIC8vIE1hdGguY2VpbCBjYW4gZ28gb3ZlciBib3VuZHNcclxuICAgICAgICAgICAgaXkxID0gKCBNYXRoLmNlaWwoaXl2KSA+IChzcmNJbWcuaGVpZ2h0LTEpID8gKHNyY0ltZy5oZWlnaHQtMSkgOiBNYXRoLmNlaWwoaXl2KSApO1xyXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZGVzdEltZy53aWR0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICBpeHYgPSBqIC8gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICBpeDAgPSBNYXRoLmZsb29yKGl4dik7XHJcbiAgICAgICAgICAgICAgICAvLyBNYXRoLmNlaWwgY2FuIGdvIG92ZXIgYm91bmRzXHJcbiAgICAgICAgICAgICAgICBpeDEgPSAoIE1hdGguY2VpbChpeHYpID4gKHNyY0ltZy53aWR0aC0xKSA/IChzcmNJbWcud2lkdGgtMSkgOiBNYXRoLmNlaWwoaXh2KSApO1xyXG4gICAgICAgICAgICAgICAgaWR4RCA9IGl2ZWN0KGosIGksIGRlc3RJbWcud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgLy8gbWF0cml4IHRvIHZlY3RvciBpbmRpY2VzXHJcbiAgICAgICAgICAgICAgICBpZHhTMDAgPSBpdmVjdChpeDAsIGl5MCwgc3JjSW1nLndpZHRoKTtcclxuICAgICAgICAgICAgICAgIGlkeFMxMCA9IGl2ZWN0KGl4MSwgaXkwLCBzcmNJbWcud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgaWR4UzAxID0gaXZlY3QoaXgwLCBpeTEsIHNyY0ltZy53aWR0aCk7XHJcbiAgICAgICAgICAgICAgICBpZHhTMTEgPSBpdmVjdChpeDEsIGl5MSwgc3JjSW1nLndpZHRoKTtcclxuICAgICAgICAgICAgICAgIC8vIG92ZXJhbGwgY29vcmRpbmF0ZXMgdG8gdW5pdCBzcXVhcmVcclxuICAgICAgICAgICAgICAgIGR4ID0gaXh2IC0gaXgwOyBkeSA9IGl5diAtIGl5MDtcclxuICAgICAgICAgICAgICAgIC8vIEkgbGV0IHRoZSByLCBnLCBiLCBhIG9uIHB1cnBvc2UgZm9yIGRlYnVnZ2luZ1xyXG4gICAgICAgICAgICAgICAgciA9IGlubmVyKHNyY0ltZy5kYXRhW2lkeFMwMF0sIHNyY0ltZy5kYXRhW2lkeFMxMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgc3JjSW1nLmRhdGFbaWR4UzAxXSwgc3JjSW1nLmRhdGFbaWR4UzExXSwgZHgsIGR5KTtcclxuICAgICAgICAgICAgICAgIGRlc3RJbWcuZGF0YVtpZHhEXSA9IHI7XHJcblxyXG4gICAgICAgICAgICAgICAgZyA9IGlubmVyKHNyY0ltZy5kYXRhW2lkeFMwMCsxXSwgc3JjSW1nLmRhdGFbaWR4UzEwKzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIHNyY0ltZy5kYXRhW2lkeFMwMSsxXSwgc3JjSW1nLmRhdGFbaWR4UzExKzFdLCBkeCwgZHkpO1xyXG4gICAgICAgICAgICAgICAgZGVzdEltZy5kYXRhW2lkeEQrMV0gPSBnO1xyXG5cclxuICAgICAgICAgICAgICAgIGIgPSBpbm5lcihzcmNJbWcuZGF0YVtpZHhTMDArMl0sIHNyY0ltZy5kYXRhW2lkeFMxMCsyXSxcclxuICAgICAgICAgICAgICAgICAgICBzcmNJbWcuZGF0YVtpZHhTMDErMl0sIHNyY0ltZy5kYXRhW2lkeFMxMSsyXSwgZHgsIGR5KTtcclxuICAgICAgICAgICAgICAgIGRlc3RJbWcuZGF0YVtpZHhEKzJdID0gYjtcclxuXHJcbiAgICAgICAgICAgICAgICBhID0gaW5uZXIoc3JjSW1nLmRhdGFbaWR4UzAwKzNdLCBzcmNJbWcuZGF0YVtpZHhTMTArM10sXHJcbiAgICAgICAgICAgICAgICAgICAgc3JjSW1nLmRhdGFbaWR4UzAxKzNdLCBzcmNJbWcuZGF0YVtpZHhTMTErM10sIGR4LCBkeSk7XHJcbiAgICAgICAgICAgICAgICBkZXN0SW1nLmRhdGFbaWR4RCszXSA9IGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IFxyXG4gICAgfVxyXG4qL1xyXG4iXX0=