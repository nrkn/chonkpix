import { bresenhamLine } from './bresenham.js';
const createRow = (row, startCol, endCol, ...args) => [
    row, startCol, endCol, ...args
];
export const pointToRow = (x, y, ...args) => [y, x, x, ...args];
// nb - if the line is not mostly horizontal, you should just use bresenhamLine
// directly - this was more experimental than anything, though it is a lot 
// faster for its limited use case
export const lineToRows = (x0, y0, x1, y1) => {
    x0 |= 0;
    y0 |= 0;
    x1 |= 0;
    y1 |= 0;
    const steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);
    if (steep) {
        [x0, y0] = [y0, x0];
        [x1, y1] = [y1, x1];
    }
    if (x0 > x1) {
        [x0, x1] = [x1, x0];
        [y0, y1] = [y1, y0];
    }
    const dx = x1 - x0;
    const dy = Math.abs(y1 - y0);
    let err = dx / 2;
    const yStep = y0 < y1 ? 1 : -1;
    let y = y0;
    const rows = [];
    let currentRow = null;
    let spanStart = null;
    let spanEnd = null;
    for (let x = x0; x <= x1; x++) {
        const px = steep ? y : x;
        const py = steep ? x : y;
        // if first pixel, start new span
        if (currentRow === null) {
            currentRow = py;
            spanStart = px;
            spanEnd = px;
        }
        else if (currentRow === py) {
            // if consecutive, extend span
            if (px < spanStart) {
                spanStart = px;
            }
            if (px > spanEnd) {
                spanEnd = px;
            }
        }
        else {
            // row changed - store last span
            rows.push(createRow(currentRow, spanStart, spanEnd));
            // start new span
            currentRow = py;
            spanStart = px;
            spanEnd = px;
        }
        err -= dy;
        if (err < 0) {
            y += yStep;
            err += dx;
        }
    }
    // maybe push last span
    if (currentRow !== null) {
        rows.push(createRow(currentRow, spanStart, spanEnd));
    }
    return rows;
};
export const rectToRows = (x, y, w, h) => {
    const rows = [];
    for (let j = 0; j < h; j++) {
        rows.push(createRow(y + j, x, x + w - 1));
    }
    return rows;
};
// designed so that bresenham strokes can be used without gaps or overlaps.
// consider passing the bresenham lines in instead of the triangle points.
// could also be renamed and extended to fill any convex polygon.
//
// we should add a more sophisticated scanline that can handle complex polygons
// with holes etc.
export const triangleToRows = (a, b, c) => {
    const edges = [
        bresenhamLine(a[0], a[1], b[0], b[1]),
        bresenhamLine(b[0], b[1], c[0], c[1]),
        bresenhamLine(c[0], c[1], a[0], a[1])
    ];
    const edgeMap = new Map();
    for (const edge of edges) {
        for (const [x, y] of edge) {
            if (!edgeMap.has(y)) {
                edgeMap.set(y, []);
            }
            edgeMap.get(y).push(x);
        }
    }
    const rows = [];
    for (const [y, xs] of edgeMap) {
        const row = createRow(y, Math.min(...xs), Math.max(...xs));
        rows.push(row);
    }
    return rows;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm93cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvaW1hZ2Uvcm93cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sZ0JBQWdCLENBQUE7QUFJOUMsTUFBTSxTQUFTLEdBQUcsQ0FDaEIsR0FBVyxFQUFFLFFBQWdCLEVBQUUsTUFBYyxFQUFFLEdBQUcsSUFBVyxFQUNuRCxFQUFFLENBQUM7SUFDWCxHQUFHLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxHQUFHLElBQUk7Q0FDL0IsQ0FBQTtBQUVILE1BQU0sQ0FBQyxNQUFNLFVBQVUsR0FBRyxDQUN4QixDQUFTLEVBQUUsQ0FBUyxFQUFFLEdBQUcsSUFBVyxFQUMxQixFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFBO0FBRWpDLCtFQUErRTtBQUMvRSwyRUFBMkU7QUFDM0Usa0NBQWtDO0FBQ2xDLE1BQU0sQ0FBQyxNQUFNLFVBQVUsR0FBRyxDQUN4QixFQUFVLEVBQUUsRUFBVSxFQUFFLEVBQVUsRUFBRSxFQUFVLEVBQ2hDLEVBQUU7SUFDaEIsRUFBRSxJQUFJLENBQUMsQ0FBQTtJQUNQLEVBQUUsSUFBSSxDQUFDLENBQUE7SUFDUCxFQUFFLElBQUksQ0FBQyxDQUFBO0lBQ1AsRUFBRSxJQUFJLENBQUMsQ0FBQTtJQUVQLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFBO0lBRW5ELElBQUksS0FBSyxFQUFFLENBQUM7UUFDVixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUFBLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxHQUFHLENB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LENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztnQkFDcEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUE7WUFDcEIsQ0FBQztZQUVELE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFBO1FBQ3pCLENBQUM7SUFDSCxDQUFDO0lBRUQsTUFBTSxJQUFJLEdBQWlCLEVBQUUsQ0FBQTtJQUU3QixLQUFLLE1BQU0sQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksT0FBTyxFQUFFLENBQUM7UUFDOUIsTUFBTSxHQUFHLEdBQUcsU0FBUyxDQUFRLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUE7UUFFakUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQTtJQUNoQixDQUFDO0lBRUQsT0FBTyxJQUFJLENBQUE7QUFDYixDQUFDLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBicmVzZW5oYW1MaW5lIH0gZnJvbSAnLi9icmVzZW5oYW0uanMnXG5pbXBvcnQgeyBSb3cgfSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgVDIgfSBmcm9tICcuLi90eXBlcy5qcydcblxuY29uc3QgY3JlYXRlUm93ID0gPEFyZz4oXG4gIHJvdzogbnVtYmVyLCBzdGFydENvbDogbnVtYmVyLCBlbmRDb2w6IG51bWJlciwgLi4uYXJnczogQXJnW11cbik6IFJvdzxBcmc+ID0+IFtcbiAgICByb3csIHN0YXJ0Q29sLCBlbmRDb2wsIC4uLmFyZ3NcbiAgXVxuXG5leHBvcnQgY29uc3QgcG9pbnRUb1JvdyA9IDxBcmc+KFxuICB4OiBudW1iZXIsIHk6IG51bWJlciwgLi4uYXJnczogQXJnW11cbik6IFJvdzxBcmc+ID0+IFt5LCB4LCB4LCAuLi5hcmdzXVxuXG4vLyBuYiAtIGlmIHRoZSBsaW5lIGlzIG5vdCBtb3N0bHkgaG9yaXpvbnRhbCwgeW91IHNob3VsZCBqdXN0IHVzZSBicmVzZW5oYW1MaW5lXG4vLyBkaXJlY3RseSAtIHRoaXMgd2FzIG1vcmUgZXhwZXJpbWVudGFsIHRoYW4gYW55dGhpbmcsIHRob3VnaCBpdCBpcyBhIGxvdCBcbi8vIGZhc3RlciBmb3IgaXRzIGxpbWl0ZWQgdXNlIGNhc2VcbmV4cG9ydCBjb25zdCBsaW5lVG9Sb3dzID0gKFxuICB4MDogbnVtYmVyLCB5MDogbnVtYmVyLCB4MTogbnVtYmVyLCB5MTogbnVtYmVyXG4pOiBSb3c8bmV2ZXI+W10gPT4ge1xuICB4MCB8PSAwXG4gIHkwIHw9IDBcbiAgeDEgfD0gMFxuICB5MSB8PSAwXG5cbiAgY29uc3Qgc3RlZXAgPSBNYXRoLmFicyh5MSAtIHkwKSA+IE1hdGguYWJzKHgxIC0geDApXG5cbiAgaWYgKHN0ZWVwKSB7XG4gICAgW3gwLCB5MF0gPSBbeTAsIHgwXTtbeDEsIHkxXSA9IFt5MSwgeDFdXG4gIH1cblxuICBpZiAoeDAgPiB4MSkge1xuICAgIFt4MCwgeDFdID0gW3gxLCB4MF07W3kwLCB5MV0gPSBbeTEsIHkwXVxuICB9XG5cbiAgY29uc3QgZHggPSB4MSAtIHgwXG4gIGNvbnN0IGR5ID0gTWF0aC5hYnMoeTEgLSB5MClcblxuICBsZXQgZXJyID0gZHggLyAyXG5cbiAgY29uc3QgeVN0ZXAgPSB5MCA8IHkxID8gMSA6IC0xXG5cbiAgbGV0IHkgPSB5MFxuXG4gIGNvbnN0IHJvd3M6IFJvdzxuZXZlcj5bXSA9IFtdXG5cbiAgbGV0IGN1cnJlbnRSb3c6IG51bWJlciB8IG51bGwgPSBudWxsXG4gIGxldCBzcGFuU3RhcnQ6IG51bWJlciB8IG51bGwgPSBudWxsXG4gIGxldCBzcGFuRW5kOiBudW1iZXIgfCBudWxsID0gbnVsbFxuXG4gIGZvciAobGV0IHggPSB4MDsgeCA8PSB4MTsgeCsrKSB7XG4gICAgY29uc3QgcHggPSBzdGVlcCA/IHkgOiB4XG4gICAgY29uc3QgcHkgPSBzdGVlcCA/IHggOiB5XG5cbiAgICAvLyBpZiBmaXJzdCBwaXhlbCwgc3RhcnQgbmV3IHNwYW5cbiAgICBpZiAoY3VycmVudFJvdyA9PT0gbnVsbCkge1xuICAgICAgY3VycmVudFJvdyA9IHB5XG4gICAgICBzcGFuU3RhcnQgPSBweFxuICAgICAgc3BhbkVuZCA9IHB4XG4gICAgfSBlbHNlIGlmIChjdXJyZW50Um93ID09PSBweSkge1xuICAgICAgLy8gaWYgY29uc2VjdXRpdmUsIGV4dGVuZCBzcGFuXG4gICAgICBpZiAocHggPCBzcGFuU3RhcnQhKSB7XG4gICAgICAgIHNwYW5TdGFydCA9IHB4XG4gICAgICB9XG4gICAgICBpZiAocHggPiBzcGFuRW5kISkge1xuICAgICAgICBzcGFuRW5kID0gcHhcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcm93IGNoYW5nZWQgLSBzdG9yZSBsYXN0IHNwYW5cbiAgICAgIHJvd3MucHVzaChjcmVhdGVSb3coY3VycmVudFJvdywgc3BhblN0YXJ0ISwgc3BhbkVuZCEpKVxuXG4gICAgICAvLyBzdGFydCBuZXcgc3BhblxuICAgICAgY3VycmVudFJvdyA9IHB5XG4gICAgICBzcGFuU3RhcnQgPSBweFxuICAgICAgc3BhbkVuZCA9IHB4XG4gICAgfVxuXG4gICAgZXJyIC09IGR5XG5cbiAgICBpZiAoZXJyIDwgMCkge1xuICAgICAgeSArPSB5U3RlcFxuICAgICAgZXJyICs9IGR4XG4gICAgfVxuICB9XG5cbiAgLy8gbWF5YmUgcHVzaCBsYXN0IHNwYW5cbiAgaWYgKGN1cnJlbnRSb3cgIT09IG51bGwpIHtcbiAgICByb3dzLnB1c2goY3JlYXRlUm93KGN1cnJlbnRSb3csIHNwYW5TdGFydCEsIHNwYW5FbmQhKSlcbiAgfVxuXG4gIHJldHVybiByb3dzXG59XG5cbmV4cG9ydCBjb25zdCByZWN0VG9Sb3dzID0gKFxuICB4OiBudW1iZXIsIHk6IG51bWJlciwgdzogbnVtYmVyLCBoOiBudW1iZXJcbik6IFJvdzxuZXZlcj5bXSA9PiB7XG4gIGNvbnN0IHJvd3M6IFJvdzxuZXZlcj5bXSA9IFtdXG5cbiAgZm9yIChsZXQgaiA9IDA7IGogPCBoOyBqKyspIHtcbiAgICByb3dzLnB1c2goY3JlYXRlUm93KHkgKyBqLCB4LCB4ICsgdyAtIDEpKVxuICB9XG5cbiAgcmV0dXJuIHJvd3Ncbn1cblxuLy8gZGVzaWduZWQgc28gdGhhdCBicmVzZW5oYW0gc3Ryb2tlcyBjYW4gYmUgdXNlZCB3aXRob3V0IGdhcHMgb3Igb3ZlcmxhcHMuXG4vLyBjb25zaWRlciBwYXNzaW5nIHRoZSBicmVzZW5oYW0gbGluZXMgaW4gaW5zdGVhZCBvZiB0aGUgdHJpYW5nbGUgcG9pbnRzLlxuLy8gY291bGQgYWxzbyBiZSByZW5hbWVkIGFuZCBleHRlbmRlZCB0byBmaWxsIGFueSBjb252ZXggcG9seWdvbi5cbi8vXG4vLyB3ZSBzaG91bGQgYWRkIGEgbW9yZSBzb3BoaXN0aWNhdGVkIHNjYW5saW5lIHRoYXQgY2FuIGhhbmRsZSBjb21wbGV4IHBvbHlnb25zXG4vLyB3aXRoIGhvbGVzIGV0Yy5cbmV4cG9ydCBjb25zdCB0cmlhbmdsZVRvUm93cyA9IChcbiAgYTogVDIsIGI6IFQyLCBjOiBUMlxuKSA9PiB7XG4gIGNvbnN0IGVkZ2VzID0gW1xuICAgIGJyZXNlbmhhbUxpbmUoYVswXSwgYVsxXSwgYlswXSwgYlsxXSksXG4gICAgYnJlc2VuaGFtTGluZShiWzBdLCBiWzFdLCBjWzBdLCBjWzFdKSxcbiAgICBicmVzZW5oYW1MaW5lKGNbMF0sIGNbMV0sIGFbMF0sIGFbMV0pXG4gIF0gYXMgY29uc3RcblxuICBjb25zdCBlZGdlTWFwID0gbmV3IE1hcDxudW1iZXIsIG51bWJlcltdPigpXG5cbiAgZm9yIChjb25zdCBlZGdlIG9mIGVkZ2VzKSB7XG4gICAgZm9yIChjb25zdCBbeCwgeV0gb2YgZWRnZSkge1xuICAgICAgaWYgKCFlZGdlTWFwLmhhcyh5KSkge1xuICAgICAgICBlZGdlTWFwLnNldCh5LCBbXSlcbiAgICAgIH1cblxuICAgICAgZWRnZU1hcC5nZXQoeSkhLnB1c2goeClcbiAgICB9XG4gIH1cblxuICBjb25zdCByb3dzOiBSb3c8bmV2ZXI+W10gPSBbXVxuXG4gIGZvciAoY29uc3QgW3ksIHhzXSBvZiBlZGdlTWFwKSB7XG4gICAgY29uc3Qgcm93ID0gY3JlYXRlUm93PG5ldmVyPih5LCBNYXRoLm1pbiguLi54cyksIE1hdGgubWF4KC4uLnhzKSlcblxuICAgIHJvd3MucHVzaChyb3cpXG4gIH1cblxuICByZXR1cm4gcm93c1xufVxuIl19