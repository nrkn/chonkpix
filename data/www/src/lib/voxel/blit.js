import { V_FRONT, V_TOP, V_X, V_Y, V_Z } from './const.js';
// painters algorithm - uses overdraw
//
// pretty fast! could be some room for improvement?
// eg should we precalculate voxels that are oob during sort phase and filter 
// them out? then we can skip three `if` checks per voxel
export const blitVoxels = (imageData, 
// assumed to be already sorted by z then y
voxels) => {
    const view = new Uint32Array(imageData.data.buffer);
    for (let i = 0; i < voxels.length; i++) {
        const vox = voxels[i];
        const vx = vox[V_X];
        const vy = vox[V_Y];
        const vz = vox[V_Z];
        const vt = vox[V_TOP];
        const vf = vox[V_FRONT];
        if (vx < 0 || vx >= imageData.width)
            continue;
        const dyTop = imageData.height - 1 - (vy + vz);
        if (dyTop >= 0 && dyTop < imageData.height) {
            const topIndex = dyTop * imageData.width + vx;
            view[topIndex] = vt;
        }
        const dyFront = dyTop + 1;
        if (dyFront >= 0 && dyFront < imageData.height) {
            const frontIndex = dyFront * imageData.width + vx;
            view[frontIndex] = vf;
        }
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmxpdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvdm94ZWwvYmxpdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxNQUFNLFlBQVksQ0FBQTtBQUcxRCxxQ0FBcUM7QUFDckMsRUFBRTtBQUNGLG1EQUFtRDtBQUNuRCw4RUFBOEU7QUFDOUUseURBQXlEO0FBQ3pELE1BQU0sQ0FBQyxNQUFNLFVBQVUsR0FBRyxDQUN4QixTQUFvQjtBQUNwQiwyQ0FBMkM7QUFDM0MsTUFBYSxFQUNiLEVBQUU7SUFDRixNQUFNLElBQUksR0FBRyxJQUFJLFdBQVcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO0lBRW5ELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDdkMsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFBO1FBQ3JCLE1BQU0sRUFBRSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQTtRQUNuQixNQUFNLEVBQUUsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUE7UUFDbkIsTUFBTSxFQUFFLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFBO1FBQ25CLE1BQU0sRUFBRSxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQTtRQUNyQixNQUFNLEVBQUUsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUE7UUFFdkIsSUFBSSxFQUFFLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxTQUFTLENBQUMsS0FBSztZQUFFLFNBQVE7UUFFN0MsTUFBTSxLQUFLLEdBQUcsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUE7UUFFOUMsSUFBSSxLQUFLLElBQUksQ0FBQyxJQUFJLEtBQUssR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDM0MsTUFBTSxRQUFRLEdBQUcsS0FBSyxHQUFHLFNBQVMsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFBO1lBRTdDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUE7UUFDckIsQ0FBQztRQUVELE1BQU0sT0FBTyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUE7UUFFekIsSUFBSSxPQUFPLElBQUksQ0FBQyxJQUFJLE9BQU8sR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDL0MsTUFBTSxVQUFVLEdBQUcsT0FBTyxHQUFHLFNBQVMsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFBO1lBRWpELElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUE7UUFDdkIsQ0FBQztJQUNILENBQUM7QUFDSCxDQUFDLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWX0ZST05ULCBWX1RPUCwgVl9YLCBWX1ksIFZfWiB9IGZyb20gJy4vY29uc3QuanMnXHJcbmltcG9ydCB7IFZveCB9IGZyb20gJy4vdHlwZXMuanMnXHJcblxyXG4vLyBwYWludGVycyBhbGdvcml0aG0gLSB1c2VzIG92ZXJkcmF3XHJcbi8vXHJcbi8vIHByZXR0eSBmYXN0ISBjb3VsZCBiZSBzb21lIHJvb20gZm9yIGltcHJvdmVtZW50P1xyXG4vLyBlZyBzaG91bGQgd2UgcHJlY2FsY3VsYXRlIHZveGVscyB0aGF0IGFyZSBvb2IgZHVyaW5nIHNvcnQgcGhhc2UgYW5kIGZpbHRlciBcclxuLy8gdGhlbSBvdXQ/IHRoZW4gd2UgY2FuIHNraXAgdGhyZWUgYGlmYCBjaGVja3MgcGVyIHZveGVsXHJcbmV4cG9ydCBjb25zdCBibGl0Vm94ZWxzID0gKFxyXG4gIGltYWdlRGF0YTogSW1hZ2VEYXRhLFxyXG4gIC8vIGFzc3VtZWQgdG8gYmUgYWxyZWFkeSBzb3J0ZWQgYnkgeiB0aGVuIHlcclxuICB2b3hlbHM6IFZveFtdXHJcbikgPT4ge1xyXG4gIGNvbnN0IHZpZXcgPSBuZXcgVWludDMyQXJyYXkoaW1hZ2VEYXRhLmRhdGEuYnVmZmVyKVxyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZveGVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3Qgdm94ID0gdm94ZWxzW2ldXHJcbiAgICBjb25zdCB2eCA9IHZveFtWX1hdXHJcbiAgICBjb25zdCB2eSA9IHZveFtWX1ldXHJcbiAgICBjb25zdCB2eiA9IHZveFtWX1pdXHJcbiAgICBjb25zdCB2dCA9IHZveFtWX1RPUF1cclxuICAgIGNvbnN0IHZmID0gdm94W1ZfRlJPTlRdXHJcblxyXG4gICAgaWYgKHZ4IDwgMCB8fCB2eCA+PSBpbWFnZURhdGEud2lkdGgpIGNvbnRpbnVlXHJcblxyXG4gICAgY29uc3QgZHlUb3AgPSBpbWFnZURhdGEuaGVpZ2h0IC0gMSAtICh2eSArIHZ6KVxyXG5cclxuICAgIGlmIChkeVRvcCA+PSAwICYmIGR5VG9wIDwgaW1hZ2VEYXRhLmhlaWdodCkge1xyXG4gICAgICBjb25zdCB0b3BJbmRleCA9IGR5VG9wICogaW1hZ2VEYXRhLndpZHRoICsgdnhcclxuXHJcbiAgICAgIHZpZXdbdG9wSW5kZXhdID0gdnRcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkeUZyb250ID0gZHlUb3AgKyAxXHJcblxyXG4gICAgaWYgKGR5RnJvbnQgPj0gMCAmJiBkeUZyb250IDwgaW1hZ2VEYXRhLmhlaWdodCkge1xyXG4gICAgICBjb25zdCBmcm9udEluZGV4ID0gZHlGcm9udCAqIGltYWdlRGF0YS53aWR0aCArIHZ4XHJcblxyXG4gICAgICB2aWV3W2Zyb250SW5kZXhdID0gdmZcclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19