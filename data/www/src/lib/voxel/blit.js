import { V_FRONT, V_TOP, V_X, V_Y, V_Z } from './const.js';
// painters algorithm - uses overdraw
//
// pretty fast! could be some room for improvement?
// eg should we precalculate voxels that are oob during sort phase and filter 
// them out? then we can skip three `if` checks per voxel
export const blitVoxels = (imageData, 
// assumed to be already sorted by z then y
voxels) => {
    const view = new Uint32Array(imageData.data.buffer);
    for (let i = 0; i < voxels.length; i++) {
        const vox = voxels[i];
        const vx = vox[V_X];
        const vy = vox[V_Y];
        const vz = vox[V_Z];
        const vt = vox[V_TOP];
        const vf = vox[V_FRONT];
        if (vx < 0 || vx >= imageData.width)
            continue;
        const dyTop = imageData.height - 1 - (vy + vz);
        if (dyTop >= 0 && dyTop < imageData.height) {
            const topIndex = dyTop * imageData.width + vx;
            view[topIndex] = vt;
        }
        const dyFront = dyTop + 1;
        if (dyFront >= 0 && dyFront < imageData.height) {
            const frontIndex = dyFront * imageData.width + vx;
            view[frontIndex] = vf;
        }
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmxpdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvdm94ZWwvYmxpdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxNQUFNLFlBQVksQ0FBQTtBQUcxRCxxQ0FBcUM7QUFDckMsRUFBRTtBQUNGLG1EQUFtRDtBQUNuRCw4RUFBOEU7QUFDOUUseURBQXlEO0FBQ3pELE1BQU0sQ0FBQyxNQUFNLFVBQVUsR0FBRyxDQUN4QixTQUFvQjtBQUNwQiwyQ0FBMkM7QUFDM0MsTUFBYSxFQUNiLEVBQUU7SUFDRixNQUFNLElBQUksR0FBRyxJQUFJLFdBQVcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO0lBRW5ELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDdkMsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFBO1FBQ3JCLE1BQU0sRUFBRSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQTtRQUNuQixNQUFNLEVBQUUsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUE7UUFDbkIsTUFBTSxFQUFFLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFBO1FBQ25CLE1BQU0sRUFBRSxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQTtRQUNyQixNQUFNLEVBQUUsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUE7UUFFdkIsSUFBSSxFQUFFLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxTQUFTLENBQUMsS0FBSztZQUFFLFNBQVE7UUFFN0MsTUFBTSxLQUFLLEdBQUcsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUE7UUFFOUMsSUFBSSxLQUFLLElBQUksQ0FBQyxJQUFJLEtBQUssR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDM0MsTUFBTSxRQUFRLEdBQUcsS0FBSyxHQUFHLFNBQVMsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFBO1lBRTdDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUE7UUFDckIsQ0FBQztRQUVELE1BQU0sT0FBTyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUE7UUFFekIsSUFBSSxPQUFPLElBQUksQ0FBQyxJQUFJLE9BQU8sR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDL0MsTUFBTSxVQUFVLEdBQUcsT0FBTyxHQUFHLFNBQVMsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFBO1lBRWpELElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUE7UUFDdkIsQ0FBQztJQUNILENBQUM7QUFDSCxDQUFDLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWX0ZST05ULCBWX1RPUCwgVl9YLCBWX1ksIFZfWiB9IGZyb20gJy4vY29uc3QuanMnXG5pbXBvcnQgeyBWb3ggfSBmcm9tICcuL3R5cGVzLmpzJ1xuXG4vLyBwYWludGVycyBhbGdvcml0aG0gLSB1c2VzIG92ZXJkcmF3XG4vL1xuLy8gcHJldHR5IGZhc3QhIGNvdWxkIGJlIHNvbWUgcm9vbSBmb3IgaW1wcm92ZW1lbnQ/XG4vLyBlZyBzaG91bGQgd2UgcHJlY2FsY3VsYXRlIHZveGVscyB0aGF0IGFyZSBvb2IgZHVyaW5nIHNvcnQgcGhhc2UgYW5kIGZpbHRlciBcbi8vIHRoZW0gb3V0PyB0aGVuIHdlIGNhbiBza2lwIHRocmVlIGBpZmAgY2hlY2tzIHBlciB2b3hlbFxuZXhwb3J0IGNvbnN0IGJsaXRWb3hlbHMgPSAoXG4gIGltYWdlRGF0YTogSW1hZ2VEYXRhLFxuICAvLyBhc3N1bWVkIHRvIGJlIGFscmVhZHkgc29ydGVkIGJ5IHogdGhlbiB5XG4gIHZveGVsczogVm94W11cbikgPT4ge1xuICBjb25zdCB2aWV3ID0gbmV3IFVpbnQzMkFycmF5KGltYWdlRGF0YS5kYXRhLmJ1ZmZlcilcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZveGVscy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZveCA9IHZveGVsc1tpXVxuICAgIGNvbnN0IHZ4ID0gdm94W1ZfWF1cbiAgICBjb25zdCB2eSA9IHZveFtWX1ldXG4gICAgY29uc3QgdnogPSB2b3hbVl9aXVxuICAgIGNvbnN0IHZ0ID0gdm94W1ZfVE9QXVxuICAgIGNvbnN0IHZmID0gdm94W1ZfRlJPTlRdXG5cbiAgICBpZiAodnggPCAwIHx8IHZ4ID49IGltYWdlRGF0YS53aWR0aCkgY29udGludWVcblxuICAgIGNvbnN0IGR5VG9wID0gaW1hZ2VEYXRhLmhlaWdodCAtIDEgLSAodnkgKyB2eilcblxuICAgIGlmIChkeVRvcCA+PSAwICYmIGR5VG9wIDwgaW1hZ2VEYXRhLmhlaWdodCkge1xuICAgICAgY29uc3QgdG9wSW5kZXggPSBkeVRvcCAqIGltYWdlRGF0YS53aWR0aCArIHZ4XG5cbiAgICAgIHZpZXdbdG9wSW5kZXhdID0gdnRcbiAgICB9XG5cbiAgICBjb25zdCBkeUZyb250ID0gZHlUb3AgKyAxXG5cbiAgICBpZiAoZHlGcm9udCA+PSAwICYmIGR5RnJvbnQgPCBpbWFnZURhdGEuaGVpZ2h0KSB7XG4gICAgICBjb25zdCBmcm9udEluZGV4ID0gZHlGcm9udCAqIGltYWdlRGF0YS53aWR0aCArIHZ4XG5cbiAgICAgIHZpZXdbZnJvbnRJbmRleF0gPSB2ZlxuICAgIH1cbiAgfVxufVxuIl19