import { V_FRONT, V_TOP, V_X, V_Y, V_Z } from './const.js';
// painters algorithm - uses overdraw
//
// pretty fast! could be some room for improvement?
// eg should we precalculate voxels that are oob during sort phase and filter 
// them out? then we can skip two `if` checks per voxel
export const blitVoxels = (imageData, 
// assumed to be already sorted by z then y
voxels, dx = 0, dy = 0 // todo - use transfer instead of offset
) => {
    const view = new Uint32Array(imageData.data.buffer);
    for (let i = 0; i < voxels.length; i++) {
        const vox = voxels[i];
        const dxLeft = vox[V_X] + dx;
        if (dxLeft < 0 || dxLeft >= imageData.width)
            continue;
        const dyTop = imageData.height - 1 - (vox[V_Y] + vox[V_Z]) + dy;
        if (dyTop >= 0 && dyTop < imageData.height) {
            const topIndex = dyTop * imageData.width + dxLeft;
            view[topIndex] = vox[V_TOP];
        }
        const dyFront = dyTop + 1;
        if (dyFront >= 0 && dyFront < imageData.height) {
            const frontIndex = dyFront * imageData.width + dxLeft;
            view[frontIndex] = vox[V_FRONT];
        }
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmxpdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvdm94ZWwvYmxpdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxNQUFNLFlBQVksQ0FBQTtBQUcxRCxxQ0FBcUM7QUFDckMsRUFBRTtBQUNGLG1EQUFtRDtBQUNuRCw4RUFBOEU7QUFDOUUsdURBQXVEO0FBQ3ZELE1BQU0sQ0FBQyxNQUFNLFVBQVUsR0FBRyxDQUN4QixTQUFvQjtBQUNwQiwyQ0FBMkM7QUFDM0MsTUFBYSxFQUNiLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyx3Q0FBd0M7RUFDdkQsRUFBRTtJQUNGLE1BQU0sSUFBSSxHQUFHLElBQUksV0FBVyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUE7SUFFbkQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUN2QyxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUE7UUFFckIsTUFBTSxNQUFNLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQTtRQUU1QixJQUFJLE1BQU0sR0FBRyxDQUFDLElBQUksTUFBTSxJQUFJLFNBQVMsQ0FBQyxLQUFLO1lBQUUsU0FBUTtRQUVyRCxNQUFNLEtBQUssR0FBRyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUE7UUFFL0QsSUFBSSxLQUFLLElBQUksQ0FBQyxJQUFJLEtBQUssR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDM0MsTUFBTSxRQUFRLEdBQUcsS0FBSyxHQUFHLFNBQVMsQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFBO1lBRWpELElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUE7UUFDN0IsQ0FBQztRQUVELE1BQU0sT0FBTyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUE7UUFFekIsSUFBSSxPQUFPLElBQUksQ0FBQyxJQUFJLE9BQU8sR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDL0MsTUFBTSxVQUFVLEdBQUcsT0FBTyxHQUFHLFNBQVMsQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFBO1lBRXJELElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUE7UUFDakMsQ0FBQztJQUNILENBQUM7QUFDSCxDQUFDLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWX0ZST05ULCBWX1RPUCwgVl9YLCBWX1ksIFZfWiB9IGZyb20gJy4vY29uc3QuanMnXHJcbmltcG9ydCB7IFZveCB9IGZyb20gJy4vdHlwZXMuanMnXHJcblxyXG4vLyBwYWludGVycyBhbGdvcml0aG0gLSB1c2VzIG92ZXJkcmF3XHJcbi8vXHJcbi8vIHByZXR0eSBmYXN0ISBjb3VsZCBiZSBzb21lIHJvb20gZm9yIGltcHJvdmVtZW50P1xyXG4vLyBlZyBzaG91bGQgd2UgcHJlY2FsY3VsYXRlIHZveGVscyB0aGF0IGFyZSBvb2IgZHVyaW5nIHNvcnQgcGhhc2UgYW5kIGZpbHRlciBcclxuLy8gdGhlbSBvdXQ/IHRoZW4gd2UgY2FuIHNraXAgdHdvIGBpZmAgY2hlY2tzIHBlciB2b3hlbFxyXG5leHBvcnQgY29uc3QgYmxpdFZveGVscyA9IChcclxuICBpbWFnZURhdGE6IEltYWdlRGF0YSxcclxuICAvLyBhc3N1bWVkIHRvIGJlIGFscmVhZHkgc29ydGVkIGJ5IHogdGhlbiB5XHJcbiAgdm94ZWxzOiBWb3hbXSxcclxuICBkeCA9IDAsIGR5ID0gMCAvLyB0b2RvIC0gdXNlIHRyYW5zZmVyIGluc3RlYWQgb2Ygb2Zmc2V0XHJcbikgPT4ge1xyXG4gIGNvbnN0IHZpZXcgPSBuZXcgVWludDMyQXJyYXkoaW1hZ2VEYXRhLmRhdGEuYnVmZmVyKVxyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZveGVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3Qgdm94ID0gdm94ZWxzW2ldXHJcblxyXG4gICAgY29uc3QgZHhMZWZ0ID0gdm94W1ZfWF0gKyBkeFxyXG5cclxuICAgIGlmIChkeExlZnQgPCAwIHx8IGR4TGVmdCA+PSBpbWFnZURhdGEud2lkdGgpIGNvbnRpbnVlXHJcblxyXG4gICAgY29uc3QgZHlUb3AgPSBpbWFnZURhdGEuaGVpZ2h0IC0gMSAtICh2b3hbVl9ZXSArIHZveFtWX1pdKSArIGR5XHJcblxyXG4gICAgaWYgKGR5VG9wID49IDAgJiYgZHlUb3AgPCBpbWFnZURhdGEuaGVpZ2h0KSB7XHJcbiAgICAgIGNvbnN0IHRvcEluZGV4ID0gZHlUb3AgKiBpbWFnZURhdGEud2lkdGggKyBkeExlZnRcclxuXHJcbiAgICAgIHZpZXdbdG9wSW5kZXhdID0gdm94W1ZfVE9QXVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGR5RnJvbnQgPSBkeVRvcCArIDFcclxuXHJcbiAgICBpZiAoZHlGcm9udCA+PSAwICYmIGR5RnJvbnQgPCBpbWFnZURhdGEuaGVpZ2h0KSB7XHJcbiAgICAgIGNvbnN0IGZyb250SW5kZXggPSBkeUZyb250ICogaW1hZ2VEYXRhLndpZHRoICsgZHhMZWZ0XHJcblxyXG4gICAgICB2aWV3W2Zyb250SW5kZXhdID0gdm94W1ZfRlJPTlRdXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdfQ==